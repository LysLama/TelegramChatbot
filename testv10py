import os
import asyncio
import uuid
import re
from dotenv import load_dotenv
load_dotenv()
from gtts import gTTS
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ConversationHandler,
    CallbackQueryHandler,
    ContextTypes
)
import google.generativeai as genai
from langdetect import detect, LangDetectException

# Configure Gemini API
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
genai.configure(api_key=GEMINI_API_KEY)

# Telegram Bot Token
TELE_TOKEN = os.getenv("TELE_TOKEN")
SAVE_DIR = "./data"
os.makedirs(SAVE_DIR, exist_ok=True)    

# Conversation states
PROCESSING_QUESTION = 1
MAX_TOKENS = 10000

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Reset conversation and start fresh"""
    context.user_data.clear()
    context.user_data["total_used_tokens"] = 0
    await update.message.reply_text("G·ª≠i cho t√¥i c√¢u h·ªèi c·ªßa b·∫°n:")
    return PROCESSING_QUESTION

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle initial message without /start command"""
    context.user_data["total_used_tokens"] = 0
    return await process_question(update, context)

async def process_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Main question processing flow"""
    question = update.message.text
    context.user_data["question"] = question
    
    # Start loading animation
    loading_task = asyncio.create_task(animate_loading(update, context))
    context.user_data["loading_task"] = loading_task

    # Detect language
    try:
        lang = detect(question)
        context.user_data["lang"] = lang
    except LangDetectException:
        lang = "en"
        context.user_data["lang"] = lang

    # Process question
    return await generate_response(update, context)

async def animate_loading(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Animated loading message"""
    message = await update.message.reply_text("ƒêang x·ª≠ l√Ω")
    dots = 0
    while True:
        dots = (dots + 1) % 4
        try:
            await message.edit_text("ƒêang x·ª≠ l√Ω" + "." * dots)
            await asyncio.sleep(0.5)
        except:
            break

async def generate_response(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Generate and handle response"""
    # Stop loading animation
    if "loading_task" in context.user_data:
        context.user_data["loading_task"].cancel()
        del context.user_data["loading_task"]

    # Show response type selector
    keyboard = [
        [
            InlineKeyboardButton("Text", callback_data="text"),
            InlineKeyboardButton("Audio", callback_data="audio"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.message.reply_text("Ch·ªçn ƒë·ªãnh d·∫°ng tr·∫£ l·ªùi:", reply_markup=reply_markup)
    else:
        await context.bot.send_message(chat_id=update.effective_chat.id, 
                                     text="Ch·ªçn ƒë·ªãnh d·∫°ng tr·∫£ l·ªùi:", 
                                     reply_markup=reply_markup)
    
    return PROCESSING_QUESTION

async def handle_response(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle response type selection"""
    query = update.callback_query
    await query.answer()
    
    # Remove original keyboard
    await query.edit_message_reply_markup(reply_markup=None)
    
    response_type = query.data
    question = context.user_data.get("question", "")
    lang = context.user_data.get("lang", "en")
    
    # Start processing animation
    processing_msg = await query.message.reply_text("üîÑ ƒêang t·∫°o ph·∫£n h·ªìi...")
    
    try:
        # Token management
        total_used = context.user_data.get("total_used_tokens", 0)
        if total_used >= MAX_TOKENS:
            await processing_msg.edit_text("‚ùå ƒê√£ h·∫øt token kh·∫£ d·ª•ng!")
            return await end_conversation(update, context)

        # Generate response
        model = genai.GenerativeModel("gemini-pro")
        response = model.generate_content(question[:1500])  # Truncate long questions
        
        if not response.text:
            raise ValueError("Empty response from API")
            
        response_text = response.text.strip().replace('*', '')
        response_text = remove_urls(response_text)
        
        # Update token count
        used_tokens = estimate_tokens(question) + estimate_tokens(response_text)
        context.user_data["total_used_tokens"] = total_used + used_tokens
        
        # Add token info
        response_text += f"\n\nüî∏ Token ƒë√£ d√πng: {context.user_data['total_used_tokens']}/{MAX_TOKENS}"
        context.user_data["last_response"] = response_text

        # Handle response type
        if response_type == "audio":
            await send_audio_response(query, response_text, lang, context)
        else:
            await processing_msg.edit_text(response_text)
            
        # Show conversion options
        keyboard = [
            [
                InlineKeyboardButton("üîä Chuy·ªÉn sang Audio", callback_data="convert_audio"),
                InlineKeyboardButton("üìù Chuy·ªÉn sang Text", callback_data="convert_text")
            ]
        ]
        await query.message.reply_text("Ch·ªçn ƒë·ªãnh d·∫°ng kh√°c:", 
                                     reply_markup=InlineKeyboardMarkup(keyboard))
        
    except Exception as e:
        await processing_msg.edit_text(f"‚ùå L·ªói: {str(e)}")
        return await end_conversation(update, context)
    
    return PROCESSING_QUESTION

async def send_audio_response(query, text, lang, context):
    """T·∫°o v√† g·ª≠i ph·∫£n h·ªìi √¢m thanh."""
    # Lo·∫°i b·ªè URL kh·ªèi vƒÉn b·∫£n d√†nh cho √¢m thanh
    text_for_audio = remove_urls(text, remove=True)
    
    # T·∫°o t·ªáp √¢m thanh t·ª´ vƒÉn b·∫£n ƒë√£ lo·∫°i b·ªè URL
    audio_path = os.path.join(SAVE_DIR, f"response_{uuid.uuid4()}.mp3")
    tts = gTTS(text=text_for_audio, lang='vi' if lang == 'vi' else 'en', slow=False)
    tts.save(audio_path)
    
    # G·ª≠i t·ªáp √¢m thanh cho ng∆∞·ªùi d√πng
    await context.bot.send_voice(chat_id=query.message.chat_id, voice=open(audio_path, "rb"))
    
    # X√≥a t·ªáp √¢m thanh sau m·ªôt kho·∫£ng th·ªùi gian
    asyncio.create_task(delete_file_after_delay(audio_path))

async def handle_conversion(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle format conversion"""
    query = update.callback_query
    await query.answer()
    
    conversion_type = query.data.split('_')[1]
    response_text = context.user_data.get("last_response", "")
    
    if conversion_type == "audio":
        await send_audio_response(query, response_text, 
                                context.user_data.get("lang", "en"), context)
    else:
        await query.message.reply_text(response_text)
    
    # Remove conversion keyboard after use
    await query.edit_message_reply_markup(reply_markup=None)
    return PROCESSING_QUESTION

async def end_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Clean up and end conversation"""
    context.user_data.clear()
    await update.message.reply_text("üí¨ K·∫øt th√∫c h·ªôi tho·∫°i. G·ª≠i tin nh·∫Øn b·∫•t k·ª≥ ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i!")
    return ConversationHandler.END

import re

def remove_urls(text, remove=True):
    """Lo·∫°i b·ªè ho·∫∑c gi·ªØ l·∫°i c√°c URL trong vƒÉn b·∫£n d·ª±a tr√™n tham s·ªë 'remove'."""
    if remove:
        url_pattern = r'https?://\S+|www\.\S+'
        return re.sub(url_pattern, "", text)
    return text

def estimate_tokens(text):
    """Estimate tokens based on word count"""
    return len(text.split()) + 1

async def delete_file_after_delay(file_path: str, delay: int = 300):
    """Delete file after specified delay"""
    await asyncio.sleep(delay)
    try:
        os.remove(file_path)
    except:
        pass

def main():
    app = Application.builder().token(TELE_TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)],
        states={
            PROCESSING_QUESTION: [
                CallbackQueryHandler(handle_response, pattern="^(text|audio)$"),
                CallbackQueryHandler(handle_conversion, pattern="^convert_(text|audio)$"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, process_question)
            ]
        },
        fallbacks=[CommandHandler("cancel", end_conversation)],
        allow_reentry=True
    )

    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("start", start))
    app.run_polling()

if __name__ == "__main__":
    main()